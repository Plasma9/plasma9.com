<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plasma9</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #f6f3ee;
      --text: #ffffff;
      --muted: #6f6f6f;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "DM Mono", monospace;
    }

    body {
      height: 100vh;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #info {
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
    }

    h1 {
      font-size: 3rem;
      font-weight: 500;
      letter-spacing: -0.03em;
      display: inline-block;
    }

    h1 span {
      display: inline-block;
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    p {
      margin-top: 14px;
      font-size: 1rem;
      color: var(--muted);
    }

    footer {
      margin-top: 42px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      #info {
        bottom: 10%;
        padding: 0 20px;
      }

      h1 {
        font-size: 2rem;
      }

      p {
        font-size: 0.9rem;
        margin-top: 10px;
      }

      footer {
        margin-top: 30px;
        font-size: 0.7rem;
      }
    }

    @media (max-width: 480px) {
      #info {
        bottom: 8%;
        padding: 0 15px;
      }

      h1 {
        font-size: 1.5rem;
      }

      p {
        font-size: 0.85rem;
        margin-top: 8px;
      }

      footer {
        margin-top: 24px;
        font-size: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="info">
    <h1 id="plasma-text">plasma9</h1>
    <p>coming soon<span id="dots"></span></p>
    <footer>Â© <span id="year"></span></footer>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0515);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Create multiple star fields for continuous looping
    const starFields = [];
    const starFieldCount = 3;
    const starCount = 1200;
    
    for (let field = 0; field < starFieldCount; field++) {
      const starsGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 1500;
        positions[i + 1] = (Math.random() - 0.5) * 1500;
        positions[i + 2] = (Math.random() - 0.5) * 1500;
      }
      
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 });
      const stars = new THREE.Points(starsGeometry, starsMaterial);
      stars.position.z = field * 300 - 150;
      scene.add(stars);
      starFields.push(stars);
    }

    const mouse = { x: 0, y: 0 };
    let lastMouseMoveTime = Date.now();
    const mouseResetTimeout = 2500;
    
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      lastMouseMoveTime = Date.now();
    });

    // Touch support for mobile
    window.addEventListener('touchmove', (event) => {
      if (event.touches.length > 0) {
        const touch = event.touches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        lastMouseMoveTime = Date.now();
      }
    });

    window.addEventListener('touchstart', (event) => {
      if (event.touches.length > 0) {
        const touch = event.touches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        lastMouseMoveTime = Date.now();
      }
    });

    // Mobile gyroscope support
    let gyro = { x: 0, y: 0 };
    let isGyroActive = false;
    
    if (window.DeviceOrientationEvent) {
      // Request permission for iOS 13+
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        // For iOS, we'll request permission on first touch
        window.addEventListener('touchstart', () => {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                enableGyro();
              }
            })
            .catch(console.error);
        }, { once: true });
      } else {
        // For Android and other devices
        enableGyro();
      }
    }
    
    function enableGyro() {
      window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
          // Beta is front-to-back tilt (-180 to 180)
          // Gamma is left-to-right tilt (-90 to 90)
          // Normalize to -1 to 1 range
          gyro.x = Math.max(-1, Math.min(1, event.gamma / 45));
          gyro.y = Math.max(-1, Math.min(1, (event.beta - 90) / 45));
          isGyroActive = true;
          lastMouseMoveTime = Date.now();
        }
      });
    }

    let model;
    let currentRotationX = 0;
    let currentRotationY = 0;
    let originalScale = 1;

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return {
        r: Math.round(255 * f(0)),
        g: Math.round(255 * f(8)),
        b: Math.round(255 * f(4))
      };
    }

    function createDefaultObject() {
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const material = new THREE.MeshPhongMaterial({
        color: 0x156064,
        shininess: 100
      });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      return cube;
    }

    function loadOBJ(url) {
      const loader = new OBJLoader();
      loader.load(
        url,
        (object) => {
          if (model) scene.remove(model);
          
          object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              child.material = new THREE.MeshBasicMaterial({
                color: 0xffffff
              });
              child.castShadow = false;
              child.receiveShadow = false;
            }
          });

          model = object;
          scene.add(model);
          
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          model.position.sub(center);
          
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 3 / maxDim;
          model.scale.multiplyScalar(scale);
          originalScale = scale;
        },
        undefined,
        (error) => {
          console.error('Error loading OBJ file:', error);
          model = createDefaultObject();
        }
      );
    }

    model = createDefaultObject();
    loadOBJ('model.obj');

    let time = 0;

    function animate() {
      requestAnimationFrame(animate);

      time += 0.001;

      // Animate each star field for continuous looping
      starFields.forEach(field => {
        field.position.z += 0.008;
        
        // When a star field passes through, move it to the back
        if (field.position.z > 150) {
          field.position.z -= 300 * starFieldCount;
        }
      });

      const timeSinceLastMove = Date.now() - lastMouseMoveTime;
      
      // Use gyro data if available (mobile), otherwise use mouse
      const inputX = isGyroActive ? gyro.x : mouse.x;
      const inputY = isGyroActive ? gyro.y : mouse.y;
      
      const targetRotationX = timeSinceLastMove > mouseResetTimeout ? 0 : -inputY * Math.PI * 0.3;
      const targetRotationY = timeSinceLastMove > mouseResetTimeout ? 0 : -inputX * Math.PI * 0.3;

      const maxRotation = Math.PI * 0.15;
      const clampedTargetX = Math.max(-maxRotation, Math.min(maxRotation, targetRotationX));
      const clampedTargetY = Math.max(-maxRotation, Math.min(maxRotation, targetRotationY));

      currentRotationX += (clampedTargetX - currentRotationX) * 0.005;
      currentRotationY += (clampedTargetY - currentRotationY) * 0.005;

     
      const driftX = Math.sin(time * 0.15) * 0.3;
      const driftY = 0;

      if (model) {
        model.rotation.x = currentRotationX + driftX;
        model.rotation.y = currentRotationY + driftY;
        
        const breathScale = 1 + Math.sin(time * 0.5) * 0.03;
        const finalScale = originalScale * breathScale;
        model.scale.set(finalScale, finalScale, finalScale);
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('year').textContent = new Date().getFullYear();

    const dotsElement = document.getElementById('dots');
    let dotCount = 0;
    
    setInterval(() => {
      dotCount = (dotCount % 3) + 1;
      dotsElement.textContent = '.'.repeat(dotCount);
      if (dotCount === 3) {
        setTimeout(() => {
          dotsElement.textContent = '';
          dotCount = 0;
        }, 2000);
      }
    }, 2000);

    const plasmaText = document.getElementById('plasma-text');
    const text = plasmaText.textContent;
    plasmaText.innerHTML = '';
    
    const letters = [];
    for (let char of text) {
      const span = document.createElement('span');
      span.textContent = char;
      span.style.display = 'inline-block';
      plasmaText.appendChild(span);
      letters.push({
        element: span,
        originalX: 0,
        originalY: 0,
        currentX: 0,
        currentY: 0,
        velocityX: 0,
        velocityY: 0
      });
    }

    setTimeout(() => {
      letters.forEach(letter => {
        const rect = letter.element.getBoundingClientRect();
        letter.originalX = rect.left + rect.width / 2;
        letter.originalY = rect.top + rect.height / 2;
      });
    }, 100);

    let mouseX = 0;
    let mouseY = 0;

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // Touch support for text animation
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
      }
    });

    document.addEventListener('touchstart', (e) => {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
      }
    });

    function animateLetters() {
      letters.forEach(letter => {
        const rect = letter.element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = centerX - mouseX;
        const dy = centerY - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const maxDistance = 150;
        const pushStrength = 8;
        
        if (distance < maxDistance) {
          const force = (1 - distance / maxDistance) * pushStrength;
          letter.velocityX += (dx / distance) * force * 0.005;
          letter.velocityY += (dy / distance) * force * 0.005;
        }
        
        letter.velocityX += (0 - letter.currentX) * 0.01;
        letter.velocityY += (0 - letter.currentY) * 0.01;
        
        letter.currentX += letter.velocityX;
        letter.currentY += letter.velocityY;
        
        letter.velocityX *= 0.93;
        letter.velocityY *= 0.93;
        
        letter.element.style.transform = `translate(${letter.currentX}px, ${letter.currentY}px)`;
      });
      
      requestAnimationFrame(animateLetters);
    }
    
    animateLetters();

    animate();
  </script>
</body>
</html>
