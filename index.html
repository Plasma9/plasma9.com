<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plasma9</title>
  <link rel="icon" type="image/png" href="v2.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #f6f3ee;
      --text: #ffffff;
      --muted: #6f6f6f;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "DM Mono", monospace;
    }

    body {
      height: 100vh;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #info {
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s;
    }

    #info.hidden {
      opacity: 0;
    }

    h1 {
      font-size: 3rem;
      font-weight: 500;
      letter-spacing: -0.03em;
      display: inline-block;
      font-family: 'Press Start 2P', monospace;
    }

    h1 span {
      display: inline-block;
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    p {
      margin-top: 14px;
      font-size: 0.7rem;
      color: var(--muted);
      font-family: 'Press Start 2P', monospace;
    }

    footer {
      margin-top: 42px;
      font-size: 0.9rem;
      color: var(--muted);
      font-family: 'Press Start 2P', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 1.5rem;
      color: var(--text);
      opacity: 0;
      transition: opacity 0.5s;
      font-family: 'Press Start 2P', monospace;
    }

    #score.active {
      opacity: 1;
    }

    #lives {
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      color: var(--text);
      opacity: 0;
      transition: opacity 0.5s;
      letter-spacing: 10px;
      text-align: center;
    }

    #lives.active {
      opacity: 1;
    }

    #playButton {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 1.5rem;
      color: var(--text);
      background: rgba(10, 5, 21, 0.8);
      border: 3px solid var(--text);
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
    }

    #playButton.visible {
      opacity: 1;
      pointer-events: all;
    }

    #playButton:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translate(-50%, -50%) scale(1.05);
    }

    #gamePrompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Press Start 2P', monospace;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    #gamePrompt.visible {
      opacity: 1;
      pointer-events: all;
    }

    #gamePrompt p {
      font-size: 1rem;
      color: var(--text);
      margin-bottom: 30px;
      line-height: 1.8;
    }

    .promptButtons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .promptButton {
      padding: 15px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 1rem;
      color: var(--text);
      background: rgba(10, 5, 21, 0.8);
      border: 3px solid var(--text);
      cursor: pointer;
      transition: all 0.3s;
    }

    .promptButton:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.05);
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Press Start 2P', monospace;
      font-size: 2rem;
      color: var(--text);
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    #gameOver.visible {
      opacity: 1;
      pointer-events: all;
    }

    #gameOver > div {
      font-family: 'Press Start 2P', monospace;
    }

    #gameOver p {
      font-size: 1rem;
      margin-top: 20px;
      margin-bottom: 30px;
      color: var(--text);
      font-family: 'Press Start 2P', monospace;
    }

    .gameOverButtons {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 30px;
    }

    .gameOverButton {
      padding: 15px 30px;
      font-family: 'Press Start 2P', monospace;
      font-size: 1rem;
      color: var(--text);
      background: rgba(10, 5, 21, 0.8);
      border: 3px solid var(--text);
      cursor: pointer;
      transition: all 0.3s;
    }

    .gameOverButton:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.05);
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      #info {
        bottom: 10%;
        padding: 0 20px;
      }

      h1 {
        font-size: 1.2rem;
      }

      p {
        font-size: 0.6rem;
        margin-top: 10px;
      }

      footer {
        margin-top: 30px;
        font-size: 0.5rem;
      }

      #gamePrompt p {
        font-size: 0.7rem;
      }

      .promptButton {
        font-size: 0.8rem;
        padding: 12px 24px;
      }

      #gameOver {
        font-size: 1.2rem;
      }

      #gameOver p {
        font-size: 0.7rem;
      }

      .gameOverButton {
        font-size: 0.8rem;
        padding: 12px 24px;
      }
    }

    @media (max-width: 480px) {
      #info {
        bottom: 8%;
        padding: 0 15px;
      }

      h1 {
        font-size: 0.9rem;
      }

      p {
        font-size: 0.5rem;
        margin-top: 8px;
      }

      footer {
        margin-top: 24px;
        font-size: 0.4rem;
      }

      #gamePrompt p {
        font-size: 0.6rem;
      }

      .promptButton {
        font-size: 0.7rem;
        padding: 10px 20px;
      }

      #gameOver {
        font-size: 1rem;
      }

      #gameOver p {
        font-size: 0.6rem;
      }

      .gameOverButton {
        font-size: 0.7rem;
        padding: 10px 20px;
      }

      #score {
        font-size: 1rem;
      }

      #lives {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="score">0</div>
  <div id="lives">♡♡♡</div>
  <div id="gamePrompt">
    <p>would you like<br>to play a game?</p>
    <div class="promptButtons">
      <button class="promptButton" id="promptYes">YES</button>
      <button class="promptButton" id="promptNo">NO</button>
    </div>
  </div>
  <div id="gameOver">
    <div>GAME OVER</div>
    <p>play again?</p>
    <div class="gameOverButtons">
      <button class="gameOverButton" id="yesButton">YES</button>
      <button class="gameOverButton" id="noButton">NO</button>
    </div>
  </div>
  
  <div id="info">
    <h1 id="plasma-text">plasma9</h1>
    <p>coming soon<span id="dots"></span></p>
    <footer><span id="year"></span></footer>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0515);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const starFields = [];
    const starFieldCount = 3;
    const starCount = 1200;
    
    for (let field = 0; field < starFieldCount; field++) {
      const starsGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 1500;
        positions[i + 1] = (Math.random() - 0.5) * 1500;
        positions[i + 2] = (Math.random() - 0.5) * 1500;
      }
      
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 });
      const stars = new THREE.Points(starsGeometry, starsMaterial);
      stars.position.z = field * 300 - 150;
      scene.add(stars);
      starFields.push(stars);
    }

    const mouse = { x: 0, y: 0 };
    let lastMouseMoveTime = Date.now();
    const mouseResetTimeout = 2500;
    
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      lastMouseMoveTime = Date.now();
    });

    window.addEventListener('touchmove', (event) => {
      if (event.touches.length > 0) {
        const touch = event.touches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        lastMouseMoveTime = Date.now();
      }
    });

    window.addEventListener('touchstart', (event) => {
      if (event.touches.length > 0) {
        const touch = event.touches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        lastMouseMoveTime = Date.now();
      }
    });

    let gyro = { x: 0, y: 0 };
    let isGyroActive = false;
    
    if (window.DeviceOrientationEvent) {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        window.addEventListener('touchstart', () => {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                enableGyro();
              }
            })
            .catch(console.error);
        }, { once: true });
      } else {
        enableGyro();
      }
    }
    
    function enableGyro() {
      window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
          gyro.x = Math.max(-1, Math.min(1, event.gamma / 45));
          gyro.y = Math.max(-1, Math.min(1, (event.beta - 90) / 45));
          isGyroActive = true;
          lastMouseMoveTime = Date.now();
        }
      });
    }

    let model;
    let currentRotationX = 0;
    let currentRotationY = 0;
    let originalScale = 1;

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return {
        r: Math.round(255 * f(0)),
        g: Math.round(255 * f(8)),
        b: Math.round(255 * f(4))
      };
    }

    function loadOBJ(url) {
      const loader = new OBJLoader();
      loader.load(
        url,
        (object) => {
          if (model) scene.remove(model);
          
          object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              child.material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1
              });
              child.castShadow = false;
              child.receiveShadow = false;
            }
          });

          model = object;
          scene.add(model);
          
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          model.position.sub(center);
          
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 3 / maxDim;
          model.scale.multiplyScalar(scale);
          originalScale = scale;
        },
        undefined,
        (error) => {
          console.error('Error loading OBJ file:', error);
        }
      );
    }

    loadOBJ('model.obj');

    let time = 0;
    let gameActive = false;
    let gameStarted = false;
    let score = 0;
    let lives = 3;
    let gameTime = 0;
    const asteroids = [];
    const projectiles = [];
    const particles = [];

    let logoClickEnabled = true;

    canvas.addEventListener('click', (event) => {
      if (logoClickEnabled && !gameActive && !gameStarted) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        if (distance < 200) {
          document.getElementById('info').classList.add('hidden');
          
          if (model) {
            model.traverse((child) => {
              if (child.material) {
                child.material.transparent = true;
                const fadeOut = setInterval(() => {
                  if (child.material.opacity > 0) {
                    child.material.opacity -= 0.05;
                  } else {
                    clearInterval(fadeOut);
                  }
                }, 30);
              }
            });
          }
          
          setTimeout(() => {
            document.getElementById('gamePrompt').classList.add('visible');
          }, 500);
          
          logoClickEnabled = false;
        }
      }
    });

    canvas.addEventListener('touchstart', (event) => {
      if (logoClickEnabled && !gameActive && !gameStarted) {
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        if (distance < 200) {
          document.getElementById('info').classList.add('hidden');
          
          if (model) {
            model.traverse((child) => {
              if (child.material) {
                child.material.transparent = true;
                const fadeOut = setInterval(() => {
                  if (child.material.opacity > 0) {
                    child.material.opacity -= 0.05;
                  } else {
                    clearInterval(fadeOut);
                  }
                }, 30);
              }
            });
          }
          
          setTimeout(() => {
            document.getElementById('gamePrompt').classList.add('visible');
          }, 500);
          
          logoClickEnabled = false;
        }
      }
    });

    document.getElementById('promptYes').addEventListener('click', startGame);
    document.getElementById('promptNo').addEventListener('click', () => {
      document.getElementById('gamePrompt').classList.remove('visible');
      document.getElementById('info').classList.remove('hidden');
      logoClickEnabled = true;
      
      if (model) {
        model.traverse((child) => {
          if (child.material) {
            child.material.opacity = 1;
          }
        });
      }
    });
    document.getElementById('yesButton').addEventListener('click', restartGame);
    document.getElementById('noButton').addEventListener('click', () => {
      document.getElementById('gameOver').classList.remove('visible');
      document.getElementById('info').classList.remove('hidden');
      document.getElementById('score').classList.remove('active');
      document.getElementById('lives').classList.remove('active');
      logoClickEnabled = true;
      gameStarted = false;
      
      if (model) {
        model.traverse((child) => {
          if (child.material) {
            child.material.opacity = 1;
          }
        });
      }
      
      setTimeout(() => {
        document.getElementById('playButton').classList.add('visible');
        document.getElementById('meanwhileText').classList.add('visible');
      }, 500);
    });

    function startGame() {
      gameActive = true;
      gameStarted = true;
      gameTime = 0;
      document.getElementById('gamePrompt').classList.remove('visible');
      document.getElementById('info').classList.add('hidden');
      document.getElementById('score').classList.add('active');
      document.getElementById('lives').classList.add('active');
      
      if (model) {
        model.traverse((child) => {
          if (child.material) {
            child.material.transparent = true;
            const fadeOut = setInterval(() => {
              if (child.material.opacity > 0) {
                child.material.opacity -= 0.05;
              } else {
                clearInterval(fadeOut);
              }
            }, 30);
          }
        });
      }
    }

    function restartGame() {
      score = 0;
      lives = 3;
      gameActive = true;
      gameStarted = true;
      gameTime = 0;
      document.getElementById('score').textContent = '0';
      document.getElementById('lives').textContent = '♡♡♡';
      document.getElementById('gameOver').classList.remove('visible');
      document.getElementById('info').classList.add('hidden');
      document.getElementById('score').classList.add('active');
      document.getElementById('lives').classList.add('active');
      
      if (model) {
        model.traverse((child) => {
          if (child.material) {
            child.material.opacity = 0;
          }
        });
      }
      
      asteroids.forEach(a => scene.remove(a));
      projectiles.forEach(p => scene.remove(p));
      particles.forEach(p => scene.remove(p));
      asteroids.length = 0;
      projectiles.length = 0;
      particles.length = 0;
    }

    function loseLife() {
      lives--;
      const hearts = ['', '♡', '♡♡', '♡♡♡'];
      document.getElementById('lives').textContent = hearts[lives];
      
      if (lives <= 0) {
        gameActive = false;
        
        asteroids.forEach((asteroid) => {
          createParticles(asteroid.position);
          scene.remove(asteroid);
        });
        asteroids.length = 0;
        
        setTimeout(() => {
          document.getElementById('gameOver').classList.add('visible');
        }, 500);
      }
    }

    function createAsteroid() {
      const size = 2 + Math.random() * 2;
      const geometry = new THREE.IcosahedronGeometry(size, 0);
      const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      const asteroid = new THREE.Mesh(geometry, material);
      
      const aspectRatio = window.innerWidth / window.innerHeight;
      const angle = Math.random() * Math.PI * 2;
      const distance = 80 + Math.random() * 30;
      const horizontalScale = aspectRatio > 1.5 ? 1.2 : (aspectRatio > 1 ? 1 : 0.8);
      const verticalScale = aspectRatio < 0.75 ? 1.2 : (aspectRatio < 1 ? 1 : 0.8);
      
      asteroid.position.x = Math.cos(angle) * distance * horizontalScale * 0.5;
      asteroid.position.y = (Math.random() - 0.5) * 40 * verticalScale * 0.5;
      asteroid.position.z = -50 - Math.random() * 100;
      
      const direction = new THREE.Vector3(0, 0, 5).sub(asteroid.position).normalize();
      const baseSpeed = 0.08 + Math.random() * 0.07;
      const speedMultiplier = 1 + (gameTime * 0.1);
      const speed = baseSpeed * speedMultiplier;
      
      asteroid.userData.velocity = {
        x: direction.x * speed,
        y: direction.y * speed,
        z: direction.z * speed
      };
      
      asteroid.userData.rotationSpeed = {
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02
      };
      
      scene.add(asteroid);
      asteroids.push(asteroid);
    }

    function createProjectile(targetX, targetY) {
      const geometry = new THREE.SphereGeometry(0.2, 8, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const projectile = new THREE.Mesh(geometry, material);
      
      projectile.position.copy(camera.position);
      
      const vector = new THREE.Vector3(targetX, targetY, 0.5);
      vector.unproject(camera);
      const dir = vector.sub(camera.position).normalize();
      
      projectile.userData.velocity = dir.multiplyScalar(2);
      
      scene.add(projectile);
      projectiles.push(projectile);
    }

    function createParticles(position) {
      for (let i = 0; i < 20; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.copy(position);
        particle.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        );
        particle.userData.life = 1;
        
        scene.add(particle);
        particles.push(particle);
      }
    }

    canvas.addEventListener('click', (event) => {
      if (!gameActive) return;
      const x = (event.clientX / window.innerWidth) * 2 - 1;
      const y = -(event.clientY / window.innerHeight) * 2 + 1;
      createProjectile(x, y);
    });

    canvas.addEventListener('touchstart', (event) => {
      if (!gameActive) return;
      const touch = event.touches[0];
      const x = (touch.clientX / window.innerWidth) * 2 - 1;
      const y = -(touch.clientY / window.innerHeight) * 2 + 1;
      createProjectile(x, y);
    });

    function animate() {
      requestAnimationFrame(animate);

      time += 0.001;

      if (gameActive) {
        gameTime += 0.001;
        const spawnRate = Math.min(0.05, 0.012 + (gameTime * 0.0008));
        
        if (Math.random() < spawnRate) {
          createAsteroid();
        }

        asteroids.forEach((asteroid, index) => {
          asteroid.position.x += asteroid.userData.velocity.x;
          asteroid.position.y += asteroid.userData.velocity.y;
          asteroid.position.z += asteroid.userData.velocity.z;
          
          asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
          asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
          asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
          
          if (asteroid.position.z > 10) {
            scene.remove(asteroid);
            asteroids.splice(index, 1);
            loseLife();
          }
        });

        projectiles.forEach((projectile, pIndex) => {
          projectile.position.add(projectile.userData.velocity);
          
          if (projectile.position.length() > 200) {
            scene.remove(projectile);
            projectiles.splice(pIndex, 1);
            return;
          }
          
          asteroids.forEach((asteroid, aIndex) => {
            const distance = projectile.position.distanceTo(asteroid.position);
            const asteroidSize = asteroid.geometry.parameters.radius;
            
            if (distance < asteroidSize) {
              createParticles(asteroid.position);
              scene.remove(asteroid);
              scene.remove(projectile);
              asteroids.splice(aIndex, 1);
              projectiles.splice(pIndex, 1);
              score += 10;
              document.getElementById('score').textContent = score;
            }
          });
        });

        particles.forEach((particle, index) => {
          particle.position.add(particle.userData.velocity);
          particle.userData.life -= 0.02;
          particle.material.opacity = particle.userData.life;
          
          if (particle.userData.life <= 0) {
            scene.remove(particle);
            particles.splice(index, 1);
          }
        });
      }

      particles.forEach((particle, index) => {
        particle.position.add(particle.userData.velocity);
        particle.userData.life -= 0.02;
        particle.material.opacity = particle.userData.life;
        
        if (particle.userData.life <= 0) {
          scene.remove(particle);
          particles.splice(index, 1);
        }
      });

      starFields.forEach(field => {
        field.position.z += 0.008;
        
        if (field.position.z > 150) {
          field.position.z -= 300 * starFieldCount;
        }
      });

      const timeSinceLastMove = Date.now() - lastMouseMoveTime;
      
      const inputX = isGyroActive ? gyro.x : mouse.x;
      const inputY = isGyroActive ? gyro.y : mouse.y;
      
      const targetRotationX = timeSinceLastMove > mouseResetTimeout ? 0 : -inputY * Math.PI * 0.3;
      const targetRotationY = timeSinceLastMove > mouseResetTimeout ? 0 : -inputX * Math.PI * 0.3;

      const maxRotation = Math.PI * 0.15;
      const clampedTargetX = Math.max(-maxRotation, Math.min(maxRotation, targetRotationX));
      const clampedTargetY = Math.max(-maxRotation, Math.min(maxRotation, targetRotationY));

      currentRotationX += (clampedTargetX - currentRotationX) * 0.005;
      currentRotationY += (clampedTargetY - currentRotationY) * 0.005;

     
      const driftX = Math.sin(time * 0.15) * 0.3;
      const driftY = 0;

      if (model) {
        model.rotation.x = currentRotationX + driftX;
        model.rotation.y = currentRotationY + driftY;
        
        const breathScale = 1 + Math.sin(time * 0.5) * 0.03;
        const finalScale = originalScale * breathScale;
        model.scale.set(finalScale, finalScale, finalScale);
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('year').textContent = new Date().getFullYear();

    const dotsElement = document.getElementById('dots');
    let dotCount = 0;
    
    setInterval(() => {
      dotCount = (dotCount % 3) + 1;
      dotsElement.textContent = '.'.repeat(dotCount);
      if (dotCount === 3) {
        setTimeout(() => {
          dotsElement.textContent = '';
          dotCount = 0;
        }, 2000);
      }
    }, 2000);

    const plasmaText = document.getElementById('plasma-text');
    const text = plasmaText.textContent;
    plasmaText.innerHTML = '';
    
    const letters = [];
    for (let char of text) {
      const span = document.createElement('span');
      span.textContent = char;
      span.style.display = 'inline-block';
      plasmaText.appendChild(span);
      letters.push({
        element: span,
        originalX: 0,
        originalY: 0,
        currentX: 0,
        currentY: 0,
        velocityX: 0,
        velocityY: 0
      });
    }

    setTimeout(() => {
      letters.forEach(letter => {
        const rect = letter.element.getBoundingClientRect();
        letter.originalX = rect.left + rect.width / 2;
        letter.originalY = rect.top + rect.height / 2;
      });
    }, 100);

    let mouseX = 0;
    let mouseY = 0;

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const pushStrength = isMobile ? 15 : 8;
    const maxDistance = isMobile ? 200 : 150;

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchstart', (e) => {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
      }
    });

    function animateLetters() {
      letters.forEach(letter => {
        const rect = letter.element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = centerX - mouseX;
        const dy = centerY - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < maxDistance) {
          const force = (1 - distance / maxDistance) * pushStrength;
          letter.velocityX += (dx / distance) * force * 0.005;
          letter.velocityY += (dy / distance) * force * 0.005;
        }
        
        letter.velocityX += (0 - letter.currentX) * 0.01;
        letter.velocityY += (0 - letter.currentY) * 0.01;
        
        letter.currentX += letter.velocityX;
        letter.currentY += letter.velocityY;
        
        letter.velocityX *= 0.93;
        letter.velocityY *= 0.93;
        
        letter.element.style.transform = `translate(${letter.currentX}px, ${letter.currentY}px)`;
      });
      
      requestAnimationFrame(animateLetters);
    }
    
    animateLetters();

    animate();
  </script>
</body>
</html>
